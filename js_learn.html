<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>js_learn_2019_1_9</title>
    <script>
        // Date()
        function displayDate () {
            document.getElementById('date').innerHTML = Date();
            // document.write('<h1>1233</h1>');您只能在 HTML 输出流中使用 document.write。
            // 如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。
        };
        // element.src.match()
        function changeImg () {
            element = document.getElementById('myImage');
            // if (element.src.match('bulboff')) {
            //     element.src = './img/pic_bulbon.gif'
            // } else {
            //     element.src = './img/pic_bulboff.gif'
            // }
            element.src = element.src.match('bulboff') ? './img/pic_bulbon.gif' : './img/pic_bulboff.gif'
        };
        // element.style.color
        function changeStyle () {
            p_demo = document.getElementById('p_demo');
            p_demo.style.color = '#ff0000';
        };
        // isNaN(num)
        function isNumber () {
            const num = document.getElementById('input_number').value;
            if (num == '' || isNaN(num)) {
                alert ('不是数字')
            } else {
                alert ('是数字')
            }
        }
    </script>
    <style>
        .myDiv1, .myDiv2 {
            width: 200px;
            height: 200px;
            border: 1px solid black;
        }
        .myDiv1 {
            background-color: orange;
        }
        .myDiv2 {
            background-color: red;
        }
    </style>
</head>
<body onload="checkCookies()">
    <!--标题开始-->
    <div style="background-color: pink; padding: 6px">
        <p>1. Date()</p>
        <p>2. document.write('')</p>
        <p>3. element.src.match('')</p>
        <p>4. element.style.color</p>
        <p>5. isNaN(x)</p>
        <p>6. 科学指数e</p>
        <p>7. 一维数组的三种创建方式</p>
        <p>8. \反斜杠是一个转义字符。 转义字符将特殊字符转换为字符串字符</p>
        <p>9. getHours() || getMinutes || getSeconds</p>
        <p>10. Math.random()</p>
        <p>11. switch()</p>
        <p>12. while循环</p>
        <p>13. do/while</p>
        <p>14. 定义了数组后对数组进行赋值，中间如有某些下标未被使用（即未被赋值），
            在遍历的时候，采用一般的 for 循环和 for...in 循环得到的结果不同。
            for...in 循环会自动跳过那些没被赋值的元素，而 for 循环则不会，它会显示出 undefined。</p>
        <p>15. break</p>
        <p>16, continue</p>
        <p>17. javaScript标签</p>
        <p>18. null 和 undefined 的值相等，但类型不等</p>
        <p>19. Number() 转换为数字， String() 转换为字符串， Boolean() 转化为布尔值。</p>
        <p>20. javaScript中有5种数据类型：string || number || boolean || function || object</p>
        <p>21. 3种对象类型：Object || Date || Array</p>
        <p>22. 2个不包含任何值的数据类型：null || undefined</p>
        <p>23. typeof 操作符</p>
        <p>24. constructor 属性返回所有 JavaScript 变量的构造函数。</p>
        <p>25. 正则Regular Expression || regex || regexp || RE</p>
        <p>26. test()方法是一个正则表达式方法,返回布尔值</p>
        <p>27. exec()  方法是一个正则表达式方法,返回数组</p>
        <p>28. JS 判断输入字符串是否为数字、字母、下划线组成</p>
        <p>29. 正则表达式表单验证实例：</p>
        <p>30. JavaScript 错误 - throw、try 和 catch</p>
        <p>31. JavaScript 调试 - debugger</p>
        <p>32. JavaScript 变量提升</p>
        <p>33. JavaScript 严格模式(use strict)</p>
        <p>34. JavaScript 使用误区</p>
        <p>35. JavaScript 表单验证</p>
        <p>36. JavaScript 验证输入的数字</p>
        <p>37. input属性：required="required"</p>
        <p>38. HTML 约束验证</p>
        <p>39. JavaScript this 关键字</p>
        <p>40. JavaScript let 和 const</p>
        <p>41. JavaScript JSON</p>
        <p>42. JavaScript void</p>
        <p>43. JavaScript 函数定义</p>
        <p>44. JavaScript 箭头函数</p>
        <p>45. JavaScript 函数参数</p>
        <p>46. JavaScript 函数调用</p>
        <p>47. JavaScript 闭包</p>
        <p>48. JS DOM HTML</p>
        <p>49. JS DOM CSS</p>
        <p>50. JavaScript HTML DOM 事件</p>
        <p>51. JavaScript HTML DOM EventListener</p>
        <p>52. JavaScript HTML DOM 元素 (节点)</p>
        <p>53. JavaScript HTML DOM 集合(Collection)</p>
    </div>
    <!--标题结束-->
    <!--内容开始-->
    <!--Date()-->
    <div style="background-color: orange">
        <h3>Date()</h3>
        <p id="date">这是一个段落</p>
        <button type="button" onclick="displayDate()">显示日期</button>
    </div>
    <!--document.write()-->
    <div style="background-color: #64a5ff">
        <h3>document.write()</h3>
    </div>
    <!--element.src.match-->
    <div style="background-color: #7d7f80">
        <img id="myImage" onclick="changeImg()" src="./img/pic_bulboff.gif" alt="这是一只灯泡">
        <p>点击开关</p>
        <p>以上实例中代码 element.src.match("bulbon") 的作用意思是：检索 img 里面 src 属性的值有没有包含 bulbon 这个字符串</p>
    </div>
    <!--element.style.color-->
    <div style="background-color: #54ff41">
        <p id="p_demo">JavaScript 能改变 HTML 元素的样式</p>
        <button type="button" onclick="changeStyle()">改变样式</button>
    </div>
    <!--isNaN(num)-->
    <div style="background-color: orangered">
        <p>请输入数字。如果输入值不是数字，浏览器会弹出提示框</p>
        <input type="text" id="input_number">
        <button type="button" onclick="isNumber()">验证数字</button>
    </div>
    <!--科学指数e-->
    <div style="background-color: cornflowerblue">
        <p id="p_e1">科学指数1</p>
        <button type="button" onclick="handleE1()">科学计数</button>
        <p id="p_e2">科学指数2</p>
        <!--<button type="button" onclick="handelE1()">科学指数2</button>-->
    </div>
    <!--一维数组的三种创建方式-->
    <div style="background-color: yellow">
        <h3>1.先创建数组，再赋值</h3>
        <h3>2.在创建数组对象的时候赋值condensed array([kənˈdɛnst]浓缩的；缩写的)</h3>
        <h3>不创建对象，直接赋值literal array(literal[ˈlɪdərəl] 字面的；逐字的)</h3>
    </div>
    <!--反斜杠\-->
    <div style="background-color: cadetblue">
        <p id="back_slant1">back_slant1</p>
        <p id="back_slant2">back_slant2</p>
        <p class="back_slant3">back_slant3</p>
        <p class="back_slant4">back_slant4</p>
        <p class="back_slant5">back_slant5</p>
        <p class="back_slant6">back_slant6</p>
        <p class="back_slant7">back_slant7</p>
        <p class="back_slant8">back_slant8</p>
        <button type="button" onclick="backSlant()">反斜杠</button>
    </div>
    <!--getHours || getMinutes || getSeconds 该方法总是结合一个 Date 对象来使用new Date().getHours-->
    <div style="background-color: indianred">
        <p id="getHours">getHours</p>
        <p id="getMinutes">getMinutes</p>
        <p id="getSeconds">getSeconds</p>
        <button type="button" onclick="handleHours()">getHours</button>
        <button type="button" onclick="handleMinutes()">getMinutes</button>
        <button type="button" onclick="handleSeconds()">getSeconds</button>
    </div>
    <!--Math.random()返回介于 0（包含） ~ 1（不包含） 之间的一个随机数：-->
    <div style="background-color: slategrey">
        <p id="p_random">Math.random()返回介于 0（包含） ~ 1（不包含） 之间的一个随机数</p>
        <button type="button" onclick="changeLink()">Change</button>
    </div>
    <!--switch-->
    <div style="background-color: greenyellow">
        <p id="p_switch">switch();getDay();default</p>
        <button type="button" onclick="getDay()">获取日期</button>
    </div>
    <!--while循环-->
    <div style="background-color: indianred">
        <p id="p_while">只要指定条件为 true，循环就可以一直执行代码块。</p>
        <button onclick="handleWhile()">while循环</button>
    </div>
    <!--do/while-->
    <div style="background-color: deeppink">
        <p id="do_while">do/while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，
            然后如果条件为真的话，就会重复这个循环。
            该循环至少会执行一次，即使条件为 false 它也会执行一次，因为代码块会在条件被测试前执行：</p>
        <button onclick="doWhile()">do/while</button>
        <p>while 和 do/while 的区别 : do/while至少会执行一遍</p>
    </div>
    <!--break-->
    <div style="background-color: #7c8b22">
        <p id="do_break">break 语句可用于跳出循环。break 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）：</p>
        <button onclick="doBreak()">break</button>
    </div>
    <!--continue-->
    <div style="background-color: lightyellow">
        <p id="do_continue">continue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代</p>
        <button onclick="doContinue()">continue</button>
    </div>
    <!--javaScript标签-->
    <div style="background-color: palevioletred">
        <p id="p_label">有了标签，可以使用break和continue在多层循环的时候控制外层循环</p>
        <button onclick="doLabel()">label</button>
    </div>
    <!--null && undefined-->
    <div style="background-color: lightgreen">
        <p>null 和 undefined 的值相等，但类型不等：</p>
        <p id="null_undefined">null 和 undefined 的值相等，但类型不等</p>
        <button onclick="doDifferent()">null&undefined</button>
    </div>
    <!--typeof-->
    <div style="background-color: darkorange">
        <p id="p_typeof">可以使用 typeof 操作符来查看 JavaScript 变量的数据类型。</p>
        <button onclick="handleTypeof()">typeof</button>
        <p>如果对象是 JavaScript Array 或 JavaScript Date ，我们就无法通过 typeof 来判断他们的类型，因为都是 返回 object。</p>
    </div>
    <!--constructor-->
    <div style="background-color: mediumvioletred">
        <p>可以使用 constructor 属性来查看对象是否为数组 (包含字符串 "Array"):</p>
        <p>可以使用 constructor 属性来查看对象是否为日期 (包含字符串 "Date"):</p>
        <p id="p_constructor">element.constructor</p>
        <button onclick="handleConstructor()">constructor</button>
    </div>
    <!--Regular Expression-->
    <div style="background-color: brown">
        <p>使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式</p>
        <p>搜索模式可用于文本搜索和文本替换。</p>
        <p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
        <p>var patt = /runoob/i</p>
        <p>/runoob/i 是一个正则表达式。runoob 是一个正则表达式主体 (用于检索)。i 是一个修饰符 (搜索不区分大小写)。</p>
        <p id="p_search">search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p>
        <p>search 方法可使用字符串作为参数。字符串参数会转换为正则表达式：</p>
        <button onclick="handleSearch()">search</button>
        <p id="p_replace">replace() 方法 用于在字符串中用一些字符替换另一些字符</p>
        <p id="p_replace2">，或替换一个与正则表达式匹配的子串</p>
        <button onclick="handleReplace()">replace</button>
    </div>
    <!--test()-->
    <div style="background-color: darkslategrey">
        <p id="p_test">test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false</p>
        <p id="p_content2">content2</p>
        <p id="p_content3">content3</p>
        <p id="p_content4">content4</p>
        <button type="button" onclick="handleTest()">test()</button>
    </div>
    <!--exec()-->
    <div style="background-color: lightyellow">
        <p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</p>
        <p id="p_exec">以下实例用于搜索字符串中的字母 "e":</p>
        <p id="p_exec2">exec2</p>
        <button onclick="handleExec()">exec</button>
    </div>
    <!--正则表达式表单验证实例：-->
    <div style="background-color: purple">
        <p id="p_decimal">是否带有小数</p>
        <p>校验是否中文名称组成</p>
        <p>校验是否全由8位数字组成 </p>
        <p>校验电话码格式</p>
        <p>校验邮件地址是否合法</p>
        <button onclick="isDecimal()">isDecimal</button>
    </div>
    <!--JavaScript 错误 - throw、try 和 catch-->
    <div style="background-color: sandybrown">
        <p>try 语句测试代码块的错误。</p>
        <p>catch 语句处理错误。</p>
        <input type="button" value="try&catch" onclick="handleTry()" />
        <!--<button onclick="handleTry()">try&catch</button>-->
    </div>
    <div style="background-color: greenyellow">
        <p>不管输入是否正确，输入框都会再输入后清空。</p>
        <p>请输入 5 ~ 10 之间的数字：</p>
        <p>finally 语句不论之前的 try 和 catch 中是否产生异常都会执行该代码块</p>
        <input type="text" id="input_finally" />
        <button type="button" onclick="handleFinally()">finally</button>
        <p id="p_finally">finally</p>
    </div>
    <!--debugger-->
    <div style="background-color: dimgrey">
        <p>debugger 关键字用于停止执行 JavaScript，并调用调试函数。</p>
        <p>这个关键字与在调试工具中设置断点的效果是一样的。</p>
        <p>如果没有调试可用，debugger 语句将无法工作。</p>
        <p id="p_debugger">开启 debugger ，代码在第三行前停止执行。</p>
        <button type="button" onclick="handleDebugger()">debugger</button>
    </div>
    <!--use strict-->
    <div style="background-color: mediumvioletred">
        <p>严格模式通过在脚本或函数的头部添加 "use strict"; 表达式来声明。</p>
        <p>严格模式下你不能使用未声明的变量。</p>
        <p id="p_strict">浏览器按下 F12 开启调试模式，查看报错信息。</p>
        <button type="button" onclick="handleStrict()">use strict</button>
    </div>
    <div style="background-color: lightgoldenrodyellow">
        <p>在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法。</p>
        <p>对象只有被定义才有可能为 null，否则为 undefined。</p>
        <p></p>
    </div>
    <!--JavaScript 表单验证-->
    <div style="background-color: darkred">
        <form action="demo_form.php" name="edward_form" onsubmit="return validateForm()" method="post">
            名字：<input type="text" name="edward_fname"/>
            <input type="submit" value="提交"/>
        </form>
        <p id="p_validateForm">validateForm</p>
    </div>
    <!--JavaScript 验证输入的数字-->
    <div style="background-color: rebeccapurple">
        <p>请输入 1 到 10 之间的数字：</p>
        <input id="input_num" />
        <button type="button" onclick="handleNumber()">提交</button>
        输入：<p id="p_submit"></p>
    </div>
    <!--如果表单字段 (fname) 的值为空, required 属性会阻止表单提交：-->
    <div style="background-color: lightpink">
        <p>如果表单字段 (fname) 的值为空, required 属性会阻止表单提交：</p>
        <p>点击提交按钮，如果输入框是空的，浏览器会提示错误信息。</p>
        <form action="demo_form.php" name="edward2_form" method="post">
            名字：<input type="text" name="edward2_fname" required="required" />
            <input type="submit" name="提交" />
        </form>
    </div>
    <!--HTML 约束验证-->
    <div style="background-color: orangered">
        <p>服务端数据验证是在数据提交到服务器上后再验证</p>
        <p>客户端数据验证 side validation是在数据发送到服务器前，在浏览器上完成验证</p>
        <p>HTML5 新增了 HTML 表单的验证方式：约束验证（constraint validation）</p>
    </div>
    <!--在方法中，this 表示该方法所属的对象。-->
    <div style="background-color: dodgerblue">
        <p id="p_this"></p>
        <p>在对象方法中， this 指向调用它所在方法的对象。在上面一个实例中，this 表示 person 对象。</p>
        <p>fullName 方法所属的对象就是 person。</p>
        <p>实例中<b>this</b>指向<b>person</b>对象</p>
    </div>
    <!--单独使用 this，则它指向全局(Global)对象。-->
    <div style="background-color: deepskyblue">
        <p>单独使用 this，则它指向全局(Global)对象。</p>
        <p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
        <p id="obj_window"></p>
        <!--<button type="button" onclick="thisGlobal()">global</button>-->
    </div>
    <!--函数中使用this（默认）-->
    <div style="background-color: darkorange">
        <p id="objectWindow">在函数中，函数的所属者默认绑定到 this 上。在浏览器中，window 就是该全局对象为 [object Window]:</p>
        <p>严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined。</p>
        <!--<button type="button" onclick="objectWindow()">object Window</button>-->
    </div>
    <!--在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素：-->
    <div style="background-color: saddlebrown">
        <p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素：</p>
        <button type="button" onclick="this.style.display='none'">点击消失</button>
        <button onclick="this.style.width='123px'">点击变长</button>
    </div>
    <!--对象方法中绑定-->
    <div style="background-color: gold">
        <p>对象方法中绑定</p>
        <p id="objectObject"></p>
    </div>
    <!--显式函数绑定-->
    <div style="background-color: silver">
        <p>call()</p>
        <p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。
            这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。</p>
        <p>在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时,
            this 将指向 person2, 即便它是 person1 的方法：</p>
        <p id="p_call"></p>
    </div>
    <!--let&&const-->
    <div style="background-color: greenyellow">
        <p>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。</p>
        <p>let 声明的变量只在 let 命令所在的代码块内有效。</p>
        <p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p>
        <p>在 ES6 之前，JavaScript 只有两种作用域： 全局变量 与 函数内的局部变量。</p>
        <p>函数内使用 var 声明的变量只能在函数内容访问，如果不使用 var 则是全局变量。</p>
        <p></p>
    </div>
    <!--javascript:void(0)-->
    <div style="background-color: cyan">
        <p>javascript:void(0) 中最关键的是 void 关键字，
            void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。
        </p>
        <a href="javascript: void(0);">点击该链接无效</a>
        <a href="javascript: void(alert('2019.2.18这周末去考科二咯'))">点击弹窗</a>
        <input type="text" value="void" onclick="getVoid()" />
        <p id="p_void"></p>
        <p>
            href="#"与href="javascript:void(0)"的区别
            # 包含了一个位置信息，默认的锚是#top 也就是网页的上端。而javascript:void(0), 仅仅表示一个死链接。
            在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。
            如果你要定义一个死链接请使用 javascript:void(0)
        </p>
    </div>
    <!--JavaScript 函数定义之函数是对象-->
    <div style="background-color: fuchsia">
        <p>在 JavaScript 中使用 typeof 操作符判断函数类型将返回 "function" 。
            但是JavaScript 函数描述为一个对象更加准确。
            JavaScript 函数有 属性 和 方法。</p>
        <p>arguments.length属性返回函数调用过程接收到的参数个数</p>
        <p id="p_arguments"></p>
    </div>
    <!--箭头函数-->
    <div style="background-color: maroon">
        <h3>箭头函数</h3>
        <p>
            ES6 新增了箭头函数。箭头函数表达式的语法比普通函数表达式更简洁。
        </p>
        <div>
            <p>(参数1,参数2,…,参数N) => {函数声明}</p>
            <p>(arg1,arg2,…,argN) => 表达式（单一）</p>
            <p>相当于:(arg1,arg2,…,argN) => {return 表达式;}</p>
            <h3>当只有一个参数时，圆括号是可选的：</h3>
            <p>单一参数 => {函数声明}</p>
            <p>(单一参数) => {函数声明}</p>
            <b>没有参数的函数应该写成一对圆括号:</b>
            <p>() => {函数声明}</p>
        </div>
        <p id="p_arrow"></p>
        <p>
            有的箭头函数都没有自己的 this。 不适合顶一个 对象的方法。

            当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的。

            箭头函数是不能提升的，所以需要在使用之前定义。

            使用 const 比使用 var 更安全，因为函数表达式始终是一个常量。

            如果函数部分只是一个语句，则可以省略 return 关键字和大括号 {}，这样做是一个比较好的习惯:
        </p>
        <b>注意：IE11 及更早 IE 版本不支持箭头函数。</b>
    </div>
    <!--函数参数-->
    <div style="background-color: Olive">
        <b>Arguments对象</b>
        <p>
            JavaScript 函数有个内置的对象 arguments 对象。
            argument 对象包含了函数调用的参数数组。
        </p>
        <b>通过这种方式你可以很方便的找到最大的一个参数的值：</b>
        <p id="p_max">p_max</p>
        <b>创建一个函数用来统计所有数值的和：</b>
        <p id="p_sum">p_sum</p>
    </div>
    <!--JS DOM HTML && CSS-->
    <div style="background-color: teal">
        <p id="p_color">改变 HTML 属性</p>
        <p id="p_fontFamily">document.getElementById(id).attribute = 新属性值</p>
        <p id="p_fontSize">document.getElementById("image").src = "landscape.jpg"</p>
        <b>改变HTML样式</b>
        <p>document.getElementById(id).style.property = 新样式</p>
        <p>
            document.getElementById('p_color').style.color = "blue";
            document.getElementById('p_fontFamily').style.fontFamily = "行楷";
            document.getElementById('p_fontSize').style.fontSize = "larger";
        </p>
    </div>
    <!--JavaScript HTML DOM 事件-->
    <div style="background-color: aqua">
        <h3>onload和onunload事件</h3>
        <b>navigator.cookieEnabled</b>
        <p>
            onload 和 onunload 事件会在用户进入或离开页面时被触发。
            onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。
            onload 和 onunload 事件可用于处理 cookie。
        </p>
        <p></p>
    </div>
    <!--JavaScript HTML DOM EventListener-->
    <div style="background-color: powderblue">
        <h3>addEventListener</h3>
        <b>element.addEventListener(event, function, useCapture)</b>
        <p>
            第一个参数是事件的类型 (如 "click" 或 "mousedown").

            第二个参数是事件触发后调用的函数。

            第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。
        </p>
        <b>注意:不要使用 "on" 前缀。 例如，使用 "click" ,而不是使用 "onclick"。</b>
        <p id="p_event"></p>
        <button type="button" id="btnEvent">addEventListener</button>
        <p></p>
    </div>
    <!--向同一个元素中添加多个事件句柄-->
    <div style="background-color: aquamarine">
        <h3>向同一个元素中添加多个事件句柄</h3>
        <b>addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件：</b>
        <p>该实例使用 addEventListener() 方法向同个按钮中添加两个点击事件</p>
        <button type="button" id="btnEs">一个按钮两个点击事件</button>
        <b>你可以向同个元素添加不同类型的事件：</b>
        <button id="btnTs">一个按钮多个不同类型事件</button>
        <p id="p_btnTs"></p>
        <h3>向 Window 对象添加事件句柄</h3>
        <p>addEventListener() 方法允许你在 HTML DOM 对象添加事件监听</p>
        <p>HTML DOM 对象如： HTML 元素, HTML 文档, window 对象。或者其他支出的事件对象如: xmlHttpRequest 对象</p>
        <p id="xmlHttpRequest">当用户重置窗口大小时添加事件监听：</p>
        <b>传递参数</b>
        <p id="pParam">当传递参数值时，使用"匿名函数"调用带参数的函数：</p>
        <button id="btnParam">函数参数</button>
    </div>
    <!--事件冒泡或事件捕获？-->
    <div style="background-color: chartreuse">
        <h3>事件冒泡或事件捕获？</h3>
        <p>事件传递有两种方式：冒泡与捕获。</p>
        <p>事件传递定义了元素事件触发的顺序。 如果你将p元素插入到 div 元素中，用户点击p元素, 哪个元素的 "click" 事件先被触发呢？</p>
        <p> 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即：p 元素的点击事件先触发，然后会触发 div元素的点击事件。</p>
        <p>在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即：div元素的点击事件先触发 ，然后再触发p元素的点击事件。</p>
        <b>addEventListener() 方法可以指定 "useCapture" 参数来设置传递类型：</b>
        <p>默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。</p>
        <b>element.addEventListener(event, function, useCapture)</b>
        <b>默认值为false，即冒泡传递；当值为true时，事件使用捕获传递</b>
        <div class="myDiv1">
            <p class="myP1">这是第一个段落</p>
        </div>
        <div class="myDiv2">
            <p class="myP2">这是第二个段落</p>
        </div>
    </div>
    <!--removeEventListener() 方法-->
    <div style="background-color: chocolate">
        <h3>removeEventListener() 方法</h3>
        <p>removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄:</p>
        <div class="divOnmousemove" style="background-color: coral; padding: 50px;">div 元素添加了 onmousemove 事件句柄，鼠标在桔红色的框内移动时会显示随机数。
            <p>点击按钮移除 DIV 的事件句柄。</p>
            <button onclick="removeMove()">点击移除</button>
        </div>
        <p class="pContent"></p>
    </div>
    <!--跨浏览器解决方法:-->
    <div style="background-color: darkgoldenrod">
        <h3>跨浏览器解决方法:</h3>
        <p>IE 8 及更早 IE 版本，Opera 7.0及其更早版本不支持 addEventListener() 和 removeEventListener() 方法</p>
        <p>但是，对于这类浏览器版本可以使用 detachEvent() 方法来移除事件句柄:</p>
        <b>element.attachEvent(event, function)</b><br>
        <b>element.detachEvent(event, function)</b>
        <button id="btnAtt">attachEvent</button>
    </div>
    <!--JavaScript HTML DOM 元素 (节点)-->
    <div id="apChild" style="background-color: crimson">
        <h3>JavaScript HTML DOM 元素 (节点)</h3>
        <b>创建新的 HTML 元素 (节点) - appendChild()</b>
        <p> appendChild() 方法，它用于添加新元素到尾部。</p>
    </div>
    <!--创建新的 HTML 元素 (节点) - insertBefore()-->
    <div id="insertBefore" style="background-color: forestgreen">
        <h3 class="hInsert">创建新的 HTML 元素 (节点) - insertBefore()</h3>
        <b>如果我们需要将新元素添加到开始位置，可以使用 insertBefore() 方法:</b>
    </div>
    <!--移除已存在的元素removeChild()-->
    <div id="divParent" style="background-color: mediumspringgreen">
        <h3>移除已存在的元素removeChild()</h3>
        <p class="pChild2">要移除一个元素，你需要知道该元素的父元素。</p>
        <p class="pChild">复制：要移除一个元素，你需要知道该元素的父元素。</p>
        <b>注意：早期的 Internet Explorer 浏览器不支持 node.remove() 方法。</b>
        <p>以下代码是已知要查找的子元素，然后查找其父元素，再删除这个子元素（删除节点必须知道父节点）：</p>
        <p>
            var child = document.getElementById("p1");
            child.parentNode.removeChild(child);
        </p>
    </div>
    <!--替换 HTML 元素 - replaceChild()-->
    <div id="replaceChild" style="background-color: deepskyblue">
        <h3>替换 HTML 元素 - replaceChild(para1, para2)</h3>
        <p class="pRep">段落1</p>
        <p class="pChi">段落2</p>
    </div>
    <!--内容结束-->
<script>
    // 替换 HTML 元素 - replaceChild()
    const rC = document.getElementById('replaceChild'),
        pR = document.getElementsByClassName('pRep')[0],
        pChi = document.getElementsByClassName('pChi')[0],
        bNew = document.createElement('b'),
        bText = document.createTextNode('新的b元素');
    bNew.appendChild(bText);
    rC.replaceChild(bNew, pR);
    // 移除已存在的元素removeChild()
    const dP = document.getElementById('divParent'),
        pC = document.getElementsByClassName('pChild')[0],
        pC2 = document.getElementsByClassName('pChild2')[0];
    pC2.addEventListener('click', removeC);
    function removeC (e) {
        dP.removeChild(pC);
        e.stopPropagation();
    }
    // 创建新的 HTML 元素 (节点) - insertBefore()
    const para2 = document.createElement('h2'),
        node2 = document.createTextNode('这是一个insertBefore()插入的新标题'),
        hInsert = document.getElementsByClassName('hInsert')[0],
        insertB = document.getElementById('insertBefore');
    para2.appendChild(node2);
    insertB.insertBefore(para2, hInsert);
    // 创建新的 HTML 元素 (节点) - appendChild()
    const apChild = document.getElementById('apChild'),
        para = document.createElement('p'),
        node = document.createTextNode('这是一个createTextNode()创建的新段落');
    para.appendChild(node);
    apChild.appendChild(para);
    // addEventListener兼容性
    const btnAtt = document.getElementById('btnAtt');
    function attachEvent () {
        alert('兼容性attachEvent&&detachEvent')
    }
    if (btnAtt.addEventListener) {
        btnAtt.addEventListener('click', attachEvent)
    } else {
        btnAtt.attachEvent('onclick', attachEvent)
    }
    // removeEventListener() 方法
    const divOn = document.getElementsByClassName('divOnmousemove')[0],
        pContent = document.getElementsByClassName('pContent')[0];
    divOn.addEventListener('mousemove', addMove);
    function addMove () {
        pContent.innerHTML = Math.random()
    }
    function removeMove () {
        divOn.removeEventListener('mousemove', addMove)
    }
    // 事件冒泡或事件捕获？
    const Div1 = document.getElementsByClassName('myDiv1')[0],
        Div2 = document.getElementsByClassName('myDiv2')[0],
        P1 = document.getElementsByClassName('myP1')[0],
        P2 = document.getElementsByClassName('myP2')[0];
    Div1.addEventListener('click', function () {
        alert('myDiv1 clicked')
    }, false);
    P1.addEventListener('click', function (e) {
        alert('myP1 clicked');
        e.preventDefault();//阻止默认事件
        e.stopPropagation();//阻止冒泡事件
    }, false);
    Div2.addEventListener('click', function () {
        alert('myDiv2 clicked')
    }, true);
    P2.addEventListener('click', function () {
        alert('myP2 clicked')
    }, true);
    // 当传递参数值时，使用"匿名函数"调用带参数的函数：
    function sixFun (a, b) {
        return a*b
    }
    const p1 = 2,
            p2 = 3,
            btnParam = document.getElementById('btnParam');
    btnParam.addEventListener('click', function () {
        document.getElementById('pParam').innerHTML = sixFun (p1, p2)
    });
    // 当用户重置窗口大小时添加事件监听：
    window.addEventListener('resize', function () {
        xhr.innerHTML = Math.random()
    });
    // 向同一个元素中添加多个事件句柄
    var btnEs = document.getElementById('btnEs'),
        btnTs = document.getElementById('btnTs'),
        pbtnTs = document.getElementById('p_btnTs'),
        xhr = document.getElementById('xmlHttpRequest');
    btnEs.addEventListener('click', myFirFun);
    btnEs.addEventListener('click', mySecFun);
    function myFirFun () {
        alert ('第一个事件')
    }
    function mySecFun () {
        alert('第二个事件')
    }
    function thirFun () {
        pbtnTs.innerHTML += "onmouseover<br>"
    }
    function forthFun () {
        pbtnTs.innerHTML += "onclick<br>"
    }
    function fifthFun () {
        pbtnTs.innerHTML += "onmouseout<br>"
    }
    btnTs.addEventListener('mouseover', thirFun);
    btnTs.addEventListener("click", forthFun);
    btnTs.addEventListener("mouseout", fifthFun);
    // addEventListener
    function displayDate () {
        document.getElementById('p_event').innerHTML = Date();
    }
    document.getElementById('btnEvent').addEventListener('click',displayDate);
    // onload && onunload事件
    function checkCookies () {
        if (navigator.cookieEnabled == true) {
            alert('Cookies 可用')
        } else {
            alert('Cookies 不可用')
        }
    }
    // JS DOM HTML && CSS
    document.getElementById('p_color').style.color = "blue";
    document.getElementById('p_fontFamily').style.fontFamily = "行楷";
    document.getElementById('p_fontSize').style.fontSize = "larger";
    // Arguments对象
    const data_max = findMax(1,2,3,4,5,6),
            data_sum = findSum(1,2,3);
    function findSum () {
        var sum = 0;
        for (var i = 0; i < arguments.length; i ++) {
            sum += arguments[i];
        }
        return sum;
    }
    document.getElementById('p_sum').innerHTML = data_sum;
    function findMax () {
        var max = arguments[0];
        if (arguments.length < 2) return max;
        for (var i = 0; i < arguments.length; i ++) {
            if (arguments[i] > max)
                max = arguments[i]
        }
        return max
    }
    document.getElementById('p_max').innerHTML = data_max;
    // 箭头函数
    const dataX = (x,y) => x*y;
    document.getElementById('p_arrow').innerHTML = dataX(10, 20);
    // 函数是对象
    function myArg (a,b) {
        return arguments.length;
    }
    document.getElementById('p_arguments').innerHTML = myArg(2,3,3);//3
    // javascript:void(0);
    function getVoid () {
        var a, b, c, v;
        a = void(b = 1, c = 2);
        v = 'a: ' + a + '  b:' + b + '  c:' + c;
        document.getElementById('p_void').innerHTML = v;
    }
    // 显式函数绑定
    var person3 = {
        firstName: '楚',
        lastName: '留香',
        id: '123456'
    };
    var person4 = {
        fullName3: function () {
            return this.firstName + ' ' + this.lastName
        }
    };
    document.getElementById('p_call').innerHTML = person4.fullName3.call(person3);
    // 对象方法中绑定
    var person2 = {
        firstName: '西门',
        lastName: '吹雪',
        id: '12345',
        fullName2: function () {
            return this + this.id
        }
    }
    document.getElementById('objectObject').innerHTML = person2.fullName2();//[object Object]12345
    // 函数中使用this（默认）
    // 严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined。
    function objectWindow () {
        "use strict";
        return this;
    }
    document.getElementById('objectWindow').innerHTML = objectWindow();
        // 在浏览器中，window 就是该全局对象为 [object Window]:
    // 严格模式下，如果单独使用，this 也是指向全局(Global)对象。
        "use strict";
        var xyz = this;
        document.getElementById('obj_window').innerHTML = xyz;
    // 在方法中，this 表示该方法所属的对象。
    var person = {
        firstName: 'Hu',
        lastName: 'Edward',
        id: '1234',
        fullName: function () {
            return this.firstName + ' ' + this.lastName;
        }
    };
    document.getElementById('p_this').innerHTML = person.fullName();
    // 验证输入的数字
    function handleNumber () {
        var x, text;
        x = document.getElementById('input_num').value;
        if( isNaN(x) || x <1 || x > 10) {
            text = '错误'
        } else {
            text = '正确'
        }
        document.getElementById('p_submit').innerHTML = text;
    }
    // 表单验证
    function validateForm () {
        var x = document.forms["edward_form"]["edward_fname"].value;
        if(x == null || x == '')
            alert("请输入名字");
            return false
    }
    // use strict
    function handleStrict() {
        "use strict";
         xx = 123;
        document.getElementById('p_strict').innerHTML = xx;
    }
    // debugger
    function handleDebugger () {
        var de = 10 * 10;
        debugger;
        document.getElementById('p_debugger').innerHTML = de ;
    }
    // finally
    var x, y;
    function handleFinally () {
        x = document.getElementById('p_finally');
        x.innerHTML = '';
        y = document.getElementById('input_finally').value;
        try {
            if (y == '' ) throw '值为空';
            if(isNaN(y)) throw '值不是数字';
            if (y < 5) throw '太小';
            if (y > 10) throw '太大';
        }
        catch(err) {
            x.innerHTML = err
        }
        finally {
            document.getElementById('input_finally').value = ''
        }
    }
    // try&&catch
    var text = '';
    function handleTry () {
        try {
            addlert('Hello world') //异常的抛出
        }
        catch(error) {
            text = '本页有一个错误。\n\n';
            text += '错误信息为:'+ error.message + '\n\n';
            text += '点击确定继续。\n\n';
            alert(text) //异常的捕获与处理
        }
    }
    // 正则表达式表单验证实例：
    // 是否带有小数
    function isDecimal (decimal) {
        var RegExp = /^\d+\.\d+$/;
        return RegExp.test(decimal)
    }
    console.log(isDecimal(123));
    console.log(isDecimal(123.1))
    // exec()
    function handleExec () {
        document.getElementById('p_exec').innerHTML = /e/.exec('abcde eee'); //e
        document.getElementById('p_exec2').innerHTML = /a/.exec('bbbccdd'); // 空白
        console.log(/a/.exec('bbccdd')) //null
    }
    // test()
    function handleTest () {
        var patt1 = /money/,
            content1 = patt1.test('I have a lot of money'),
            content2 = patt1.test("You have lots of monkey"),
            patt2 = new RegExp('monkey'),
            content3 = patt2.test('I have lots of money'),
            content4 = patt2.test('You have a lot of monkey');
        document.getElementById('p_test').innerHTML = content1; //true
        document.getElementById('p_content2').innerHTML = content2; //false
        document.getElementById('p_content3').innerHTML = content3; // false
        document.getElementById('p_content4').innerHTML = content4; // true
    }
    // Regular Expression
    function handleSearch() {
        var str = 'hello World',
            m = str.search('world'),
            x = str.search('World'),
            n = str.search(/world/i);
        document.getElementById('p_search').innerHTML = String(m) + String(n) + String(x);//-1 6 6
    };
    function handleReplace () {
        var str = document.getElementById('p_replace').innerHTML,
            str2 = document.getElementById('p_replace2').innerHTML,
            x = str2.replace(/替换/i, 'replace'),
            m = str.replace('字符串','String');
        document.getElementById('p_replace').innerHTML = m;
        document.getElementById('p_replace2').innerHTML = x;
    }
    // typeof
    function handleTypeof () {
        document.getElementById('p_typeof').innerHTML =
            "1. string: " + "typeof 'string'" + "=>" + typeof 'string' + '<br>' +
            "2. number: " + "typeof 123" + "=>" + typeof 123 + '<br>' +
            "3. boolean: " + "typeof false" + "=>" + typeof false + '<br>' +
            "4. object: " + "typeof {'name': 'edward', 'age': 20}" + "=>" + typeof {'name': 'edward', 'age': 20} + '<br>' +
            "5. function: " + "typeof function () {}" + "=>" + typeof function () {} + '<br>' +
            "6. Date: " + "typeof new Date()" + "=>" + typeof new Date() + '<br>' +
            "7. Array: " + "typeof [1,2,3,4]" + "=>" + typeof [1,2,3,4] + '<br>' +
            "8. null: " + "typeof null" + "=>" + typeof null + '<br>' +
            "9. undefined: " + "typeof myCar" + "=>" + typeof myCar + '<br>' +
            "10. NaN: " + "typeof NaN" + "=>" + typeof NaN;
    };
    // constructor
    function handleConstructor () {
        document.getElementById('p_constructor').innerHTML =
            "1. string.constructor: " + '=>' +  'string'.constructor + '<br>' +
            '2. (3.14).constructor: ' + '=>' + (3.14).constructor + '<br>' +
            '3. false.constructor:' + '=>' + false.constructor + '<br>' +
            '4. [1,2,3].constructor' + '=>' + [1,2,3].constructor + '<br>' +
            "5. {'name': 'edward', 'age': 30}" + '=>' + {'name': 'edward', 'age': 30}.constructor + '<br>' +
            '6. new Date ().constructor' + '=>' + new Date().constructor + '<br>' +
            '7. function () {}.constructor' + '=>' + function () {}.constructor + '<br>' +
            // '8. null.constructor' + '=>' + null.constructor ;
            // '9. NaN.constructor' + '=>' + NaN.constructor ;
            // '10. undefined.constructor' + '=>' + myCar.constructor;
            "8. array.constructor.toString().indexOf('Array')" + '=>' + [1.2,3].constructor.toString().indexOf('Array') + '<br>' +
            "9. new Date().constructor.toString().indexOf('Date')" + '=>' + new Date().constructor.toString().indexOf('Date');
    };
    // 极大或极小的数字可以通过科学（指数）计数法来书写：
    function handleE1 () {
        const pE1 = 123e6, pE2 = 123e-6;
        p_e1 = document.getElementById('p_e1');
        p_e2 = document.getElementById('p_e2');
        p_e1.innerHTML = pE1;
        p_e2.innerHTML = pE2;
    };
    // 一维数组的三种创建方式之一
    var i;
    var arr1 = new Array();
    arr1[0] = 'apple';
    arr1[1] = 'pear';
    arr1[2] = 'peach';
    for (i = 0 ; i < arr1.length; i++) {
        document.write(arr1[i] + '<br>');
    };
    // 之二：在创建数组对象的时候赋值condensed array
    const arr2 = new Array('苹果','香蕉','桃子','芒果');
    document.write(arr2);
    // 之三：不创建对象，直接赋值literal array
    var arr3 = ['apple','西瓜','banana'];
    document.write(arr3);
    // 反斜杠back-slant
    function backSlant () {
        const slant1 = 'It\'s an apple ',
            slant2 = " He is called \"Dog\" ",
            slant3 = 'hhhhhh\\hh',
            slant4 = 'bbbb\nnnnn',
            slant5 = 'aaaa\rrrrr',
            slant6 = 'bbb\ttttt',
            slant7 = 'cccc\bbbb',
            slant8 = 'ddd\fffff';
        document.getElementById('back_slant1').innerHTML = slant1;
        document.getElementById('back_slant2').innerHTML = slant2;
        document.getElementsByClassName('back_slant4')[0].innerHTML = slant4;
        document.getElementsByClassName('back_slant5')[0].innerHTML = slant5;
        document.getElementsByClassName('back_slant6')[0].innerHTML = slant6;
        document.getElementsByClassName('back_slant7')[0].innerHTML = slant7;
        document.getElementsByClassName('back_slant8')[0].innerHTML = slant8;
        const back_slant3 = document.getElementsByClassName('back_slant3')[0];
        back_slant3.innerHTML= slant3;
    };
    //getHours || getSeconds || getMinutes
    function handleHours () {
        const hours = new Date().getHours();
        document.getElementById('getHours').innerHTML = hours.toString();
    };
    function handleMinutes () {
        const minutes = new Date().getMinutes();
        alert(minutes)
    };
    function handleSeconds () {
        const seconds = new Date().getSeconds();
        alert(seconds)
    };
    // Math.random()
    function changeLink () {
        const random = Math.random(),
            pRandom = document.getElementById('p_random');
        random > 0.5 ? pRandom.innerHTML = '<a href="https://daohang.qq.com/">导航</a>' : pRandom.innerHTML = '<a href="http://www.runoob.com/">菜鸟</a>'
    };
    //switch
    function getDay () {
        var x;
        const pSwitch = document.getElementById('p_switch'),
            day = new Date().getDay();
            console.log(day);
        switch (day) {
            case 0: x = '周日';
            break;
            case 1: x = '周一';
            break;
            case 2: x = '周二';
            break;
            case 3: x = '周三';
            break;
            case 4: x = '周四';
            break;
            default:
                x = '老子明天不上班！';
        }
        pSwitch.innerHTML = x;
    };
    // while
    function handleWhile () {
        var x = '', num = 0;
        while(num < 5) {
            num ++;
            x += '这个数字是' + num + '<br>';
        };
        document.getElementById('p_while').innerHTML = x;
    };
    // do/while
    function doWhile () {
        var x = '', num = 0;
        do {
            num ++ ;
            x += '这个数字是' + num + '<br>';
        }
        while (num < 5)
        document.getElementById('do_while').innerHTML = x ;
    };
    // break
    function doBreak () {
        var x = '', num = 0;
        for (; num < 10; num ++) {
            if ( num == 3) break;
            x += '数字为' + num + '<br>'
        }
        document.getElementById('do_break').innerHTML = x;
    };
    // continue
    function doContinue () {
        var x = '', num = 0;
        for (; num < 10; num ++) {
            if (num == 3) continue;
            x += '数字为' + num + '<br>'
        }
        document.getElementById('do_continue').innerHTML = x;
    };
    // label
    function doLabel () {
        var str = '';
        outerLoop:
        for (var i = 0; i < 10; i ++) {
            innerLoop:
            for ( var j = 0; j < 9; j ++) {
                if (j > 3) {
                    break innerLoop
                }
                if ( i == 3) {
                    break innerLoop
                }
                if ( i == 6) {
                    break outerLoop
                }
            }
           str += 'i:' + i + 'j:' + j + '<br>';
        }
        document.getElementById('p_label').innerHTML = str;
    };
    // undefined & null
    function doDifferent () {
        var x = 'undefined类型' + ' ' + typeof undefined + '<br>';
        var y = 'null类型' + ' ' + typeof null + '<br>';
        var z = 'null=== undefined' + ' ' + (null === undefined) + '<br>';
        var w = 'null == undefined' + ' ' + (null == undefined);
        document.getElementById('null_undefined').innerHTML = x + y + z + w;
    }
    // 输出时间
    document.write(Date());
</script>
</body>
<!--<script>-->
    <!--document.write(Date());-->
<!--</script>-->
</html>